# 如何告诉OpenGL我们要画什么
在讲后面内容的时候我们需要先思考一个问题，假设让你来画一幅画的话，你需要知道哪些要素了才能开始去画这幅画呢？

Android中View的源码实现绘制的时候经历了三步，首先是测量控件的大小，因为只有知道大小了才能在布局中进行定位。其次就是确定位置，不确定位置的话就不知道要画在哪。最后才是开始绘制。但是OpenGL中却并不是按照这个步骤来进行绘制的。

下面我们首先要问几个问题：
1.屏幕上为什么能显示图像，它是怎么显示出来的。
CRT显示器：高速电子束由电子枪发出，经过聚焦系统，加速系统和磁偏转系统就会达到荧光屏的指定位置。屏幕上那一点就会亮了。要保持显示一幅画就需要将屏幕上所有的像素点都扫描一遍。
彩色CRT显示器的荧光屏上涂油三种荧光物质，他们分别发红绿蓝三种颜色的光。任何颜色都是通过这三种颜色混合得来的。

2.如何形成动画
在16ms内扫描整个屏幕一次，然后连续不断的扫描 就行成了动画。

3.如何通过代码来控制屏幕的显示。
屏幕上每一个像素包含了不同的颜色信息。
我们通过代码控制的是显示区域，将要表达的图形通过顶点的形式传给图形管线，这些顶点会组成一些几何图形，这些图形最终会被拆分成大量的像素点，最后由GPU来对所有的像素点进行最后颜色的计算。





要知道从底层来讲任何一个图像引擎都包括了3个阶段：
1. **应用程序阶段**
2. **几何阶段**
3. **光栅化阶段**

应用程序阶段是通过软件方式来实现，开发者在这个阶段主要就是为后续阶段提供顶点数据。同时会监听其他的信息输入源，比如触摸事件，鼠标，声音，键盘等等，根据不同的输入去改变顶点数据。

几何阶段主要是负责对顶点组成的多边形的操作。这些多边形组成具体的模型。主要包括了矩阵变换，光照着色，投影，裁剪，屏幕映射。

光栅阶段主要是将模型涉及到的图元全部分解成屏幕上的一个个像素点。




###1.OpenGL中设置顶点的方式
OpenGL在它的坐标系上 定义一些顶点，这些顶点可以有很多属性，但最重要的属性就是位置。位置属性通过x，y，z坐标来体现。通过这些顶点与顶点的组合就形成了不同的图形，而这些图形的位置也根据每个点的位置而确定了下来。

通过代码来体现就是
```
float[] tableVertices = {
                0f, 0f,0f,
                -0.5f,-0.8f,0f,
                 0.5f,-0.8f,0f,
                 0.5f,0.8f,0f,
                -0.5f,0.8f,0f,
                -0.5f,-0.8f,0f
        };
```

但这不就是一个普通的float数组么，float数组是java的类型，而OpenGL使用的是却是另外一种语言。那么我们怎么把这份数据传递给运行在本地环境的OpenGL呢？下面就会解答这个问题。

###2.如何将java数据传递给本地系统库中的OpenGL。
要知道，Android运行代码的时候并不是直接运行在硬件上的，而是运行在Dalvik虚拟机上的。运行在虚拟机上的代码不能直接访问本地环境。除非通过特定的API的接口。Android这样设计其实也是为了降低系统的耦合性，让开发者不用去关心CPU等硬件，专心搞软件就行了。这样做一般也没问题，但在与本地系统交互的时候就比较麻烦了，比如说OpenGL。OpenGL作为本地系统库直接运行在硬件上。

继续上面那个问题：如何将java数据传递给本地系统库中的OpenGL。
有两种技术可以实现：1.使用本地接口JNI技术，这个技术已经集成在Android系统android.opengl.GLES20中，我们可以直接调用.
2.改变内存分配的方式，java有一个特殊的集合，他们可以分配本地内存快，并且把java的数据复制到本地内存。而本地内存是可以被本地环境读取，这样就可以达到传递数据的目的。

代码实现如下：
```
private FloatBuffer vertexData; //缓存的顶点数据
vertexData =
    //allocateDirect分配本地内存  float数组的长度乘以每一个float类型占用的字节数
    ByteBuffer.allocateDirect(tableVertices.length * BYTES_PER_FLOAT).
                        //告诉字节缓冲区按照本地字节序组织它的内容
                        //当一个值占用多个字节，比如32位整形数，字节按照从高位到低位 或者从低位到高位排序
                        //排什么顺序其实不重要，重要的是程序运行过程中所有的字节都得按同样的顺序排序，
                        //不能有的排正序，有的排倒序。 而  order(ByteOrder.nativeOrder()就能达到这个目的。
                        order(ByteOrder.nativeOrder())
                        //根据分配的内存获取一个能分配本地内存的FloatBuffer实例对象。
                        .asFloatBuffer();
        //将顶点数据 内存从虚拟机中拷贝到本地
        vertexData.put(tableVertices);

```

现在OpenGL已经可以读取这些数据，那么它会如何去使用这些数据呢？
这就涉及到OpenGL管线的概念了。








